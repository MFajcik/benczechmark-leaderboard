import glob
import hashlib
import os
import random
import shutil
import string
import sys
import zipfile

import pytest
import requests

FEWSHOT = 20

TASKS = [
    "benczechmark_agree",
    "benczechmark_belebele", "benczechmark_snli",
    "benczechmark_subjectivity", "benczechmark_propaganda_argumentace",
    "benczechmark_propaganda_fabulace", "benczechmark_propaganda_nazor",
    "benczechmark_propaganda_strach", "benczechmark_propaganda_zamereni",
    "benczechmark_propaganda_demonizace", "benczechmark_propaganda_lokace",
    "benczechmark_propaganda_relativizace", "benczechmark_propaganda_vina",
    "benczechmark_propaganda_zanr", "benczechmark_propaganda_emoce",
    "benczechmark_propaganda_nalepkovani", "benczechmark_propaganda_rusko",
    "benczechmark_sentiment_mall", "benczechmark_sentiment_fb",
    "benczechmark_sentiment_csfd", "benczechmark_grammarerrorcorrection",
    "benczechmark_cs_naturalquestions", "benczechmark_cs_sqad32",
    "benczechmark_cs_triviaQA", "benczechmark_csfever_nli",
    "benczechmark_ctkfacts_nli", "benczechmark_cs_ner", "benczechmark_hellaswag",
    "benczechmark_klokan_qa", "benczechmark_cs_court_decisions_ner",
    "benczechmark_umimeto_qa", "benczechmark_cermat_mc",
    "benczechmark_cermat_qa", "benczechmark_history_ir",
    "benczechmark_histcorpus", "benczechmark_essay",
    "benczechmark_fiction", "benczechmark_correspondence",
    "benczechmark_havlicek", "benczechmark_spoken",
    "benczechmark_dialect"
]

SUM_LOGPROBS = [
    "benczechmark_histcorpus", "benczechmark_essay", "benczechmark_fiction",
    "benczechmark_capek", "benczechmark_correspondence", "benczechmark_havlicek",
    "benczechmark_speeches", "benczechmark_spoken", "benczechmark_dialect"
]


def generate_random_hash(length=16):
    # Generate a random string
    random_string = ''.join(random.choices(string.ascii_letters + string.digits, k=length))

    # Create a SHA-256 hash of the random string
    random_hash = hashlib.sha256(random_string.encode()).hexdigest()

    return random_hash


def generate_argv(output_pattern, submit_file):
    return [
        "compile_log_files.py",
        "-i", output_pattern,
        "-o", submit_file,
        "-m", "benczechmark_leaderboard/leaderboard/metadata.json"
    ]


def prepare_input_dir(inp_dir,
                      backend, max_seq_len, apply_chat_template, truncate_strategy):
    # Check if the input directory exists
    if os.path.exists(inp_dir):
        # Remove the directory and its contents
        shutil.rmtree(inp_dir)
        print(f"Removed existing directory: {inp_dir}")

    # Create the input directory
    os.makedirs(inp_dir)

    TEST_OUTS_FOLDER = "lm_eval/tasks/benczechmark/tests/test_results"
    # Iterate over each task to create symlinks
    for task in TASKS:
        truncate_part = "_trunc_None" if task in SUM_LOGPROBS else f"_trunc_{truncate_strategy}"
        chat_part = "_chat_False" if task in SUM_LOGPROBS else f"_chat_{apply_chat_template}"
        output_pattern = (
            rf"{TEST_OUTS_FOLDER}/output_{task}_"
            f"model_{backend}_fewshot_{FEWSHOT}_maxlen_{max_seq_len}"
            f"{truncate_part}_logp_*{chat_part}"
        )

        fpattern = glob.glob(output_pattern)
        assert len(fpattern) == 1, f"Bad pattern {fpattern}"

        # Find files matching the output pattern for the current task
        for filename in fpattern:
            # Create a unique symlink name based on the task
            symlink_name = os.path.join(inp_dir, f"{os.path.basename(filename)}")
            absolute_filename = os.path.abspath(filename)  # Get the absolute path of the file

            try:
                os.symlink(absolute_filename, symlink_name)
                # print(f"Created symlink: {symlink_name} -> {absolute_filename}")
            except FileExistsError as e:
                print(f"Symlink already exists: {symlink_name}")
                raise e

    return inp_dir


"""
Careful, tests from BCM harness need to be ran first. 
This test relies on output folders being present in the hardcoded extraction_path
"""


@pytest.mark.parametrize("backend", ["hf"])
@pytest.mark.parametrize("max_seq_len", [1024, 2048])
@pytest.mark.parametrize("apply_chat_template", [True, False])
@pytest.mark.parametrize("truncate_strategy", [None, "leave_description"])
def test_bcm_test_out(backend, max_seq_len, apply_chat_template, truncate_strategy):
    extraction_path = "lm_eval/tasks/benczechmark/tests/test_results"  # Generated by tests

    inp_dir = prepare_input_dir(f"/tmp/test_inp_dir_{generate_random_hash()}",
                                backend, max_seq_len, apply_chat_template, truncate_strategy)

    submit_file = (f"{extraction_path}"
                   f"test_submission_"
                   f"model_{backend}_fewshot_{FEWSHOT}_maxlen_{max_seq_len}"
                   f"_trunc_{truncate_strategy}_logp_*_chat_{apply_chat_template}.json")

    sys.argv = generate_argv(inp_dir, submit_file)

    try:
        from benczechmark_leaderboard.leaderboard.compile_log_files import main
        main()
    finally:
        # Ensure inp_dir is removed whether the test succeeds or fails
        if os.path.exists(inp_dir):
            shutil.rmtree(inp_dir)  # Remove the directory and its contents


def download_and_decompress_zip(url, target_dir):
    # Create target directory if it doesn't exist
    os.makedirs(target_dir, exist_ok=True)

    # Define the path for the temporary ZIP file
    temp_zip_path = os.path.join(target_dir, "temp.zip")

    # Download the ZIP file
    response = requests.get(url)
    if response.status_code == 200:
        # Write the content to a temporary ZIP file
        with open(temp_zip_path, 'wb') as temp_zip_file:
            temp_zip_file.write(response.content)

        # Extract the contents of the ZIP file
        with zipfile.ZipFile(temp_zip_path, 'r') as zip_ref:
            zip_ref.extractall(target_dir)
            print(f"Successfully extracted ZIP contents to: {target_dir}")

        # Remove the temporary ZIP file
        os.remove(temp_zip_path)
        print(f"Removed temporary ZIP file: {temp_zip_path}")
    else:
        print(f"Failed to download file: {response.status_code}")


def test_remote_sample():
    url = "https://czechllm.fit.vutbr.cz/csmpt7b/sample_results/csmpt_logdir.zip"
    decompress_folder = f"/tmp/csmpttest_{generate_random_hash()}"
    download_and_decompress_zip(url, decompress_folder)

    inp_pattern = f"{decompress_folder}/eval_csmpt7b_benczechmark_*"
    submit_file = os.path.join(decompress_folder, "csmpttest_submission.json")

    sys.argv = generate_argv(inp_pattern, submit_file)

    try:
        from benczechmark_leaderboard.leaderboard.compile_log_files import main
        main()
    finally:
        # Ensure inp_dir is removed whether the test succeeds or fails
        if os.path.exists(decompress_folder):
            shutil.rmtree(decompress_folder)  # Remove the directory and its contents
